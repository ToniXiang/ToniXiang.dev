## 為什麼需要分頁

什麼是分頁，這裡不是指作業系統的問題，而是資料量的問題：預設每頁 N 筆資料，避免一次載入過多，保持響應速度。

- 效能考量：避免一次查詢返回大量資料，造成資料庫與網路壓力
- 使用者體驗：分頁能讓使用者逐步瀏覽，避免前端載入過慢
- 可擴展性：支援不同端點，例如：對話列表

## 分頁方式

### 1. Offset-based 分頁

- 優點：簡單易懂，適合小型資料集
- 缺點：對於大量資料或高併發情況，效能較差，且在資料於翻頁期間有新增/刪除/更新時，可能出現重複或漏資料（page drift）的一致性問題；實務上至少需要固定排序欄位（`ORDER BY` 穩定且最好是唯一的欄位）

### 2. Cursor-based 分頁

透過上一頁最後一筆資料的游標（cursor）來決定下一頁要從哪裡開始。
常見作法：內部使用資料的唯一標識（如 ID）或複合鍵；對外 API 或需要保護資料結構，需要加密後作為游標。
- 優點：效能更好，適合大量資料和高併發情況
- 缺點：實作較複雜，需要設計游標格式與驗證邏輯

### 3. Keyset-based 分頁

直接以排序欄位作為游標，在 SQL 中寫成 `WHERE (created_at, id) > (?, ?)` 等條件。

- 優點：效能優於 Offset-based，適合大量資料，查詢條件與索引策略相對直觀
- 缺點：需要確保分頁欄位的唯一性和穩定性，且對排序欄位的變更較敏感

## 設計建議

- Offset-based 為例： GET `/api/items?page=1&limit=10`
- 回傳的 JSON 結構可以包含資料和分頁資訊，例如：

```json
{
  "data": [],
  "pagination": {
    "page": 1,
    "limit": 10,
    "has_next": true
  }
}
```

- 不想做 COUNT 查詢，可以只回傳 `has_next` 來告知是否有下一頁
- `page`和`limit` 回傳值通常不能省，用來套用正確的規則

## 結論

後端一次回傳所有資料顯然不是最好的選擇，分頁機制可以減輕前後端的負擔，提升效能和使用者體驗。
根據具體需求選擇適合的分頁方式，如果資料量不會增長，則不考慮分頁。
