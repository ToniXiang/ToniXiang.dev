## 基本概念

在多數演算法與系統實作中，樹本身並不天然具備「父子關係」或「層級」這類高階語意。
底層資料結構通常只描述節點之間的無方向連結關係，例如以鄰接表表示的圖。
所謂的父子關係與節點層級，並非結構本身所提供，而是在遍歷過程中動態建立的輔助資訊。
這個遍歷可以透過遞迴（DFS），或以 for + queue 的方式進行（BFS），在走訪節點的同時，逐步推導出每個節點的來源與所在層級。
## 基本定義
假設節點編號為 0 ~ n-1，輸入 m 條邊的連接關係：
### 1. 單向圖

```cpp
vector<vector<int>> adj;
int n, m;
cin >> n >> m;
adj.assign(n, {});

for (int i = 0; i < m; i++) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);   // 單向：u → v
}
```

### 2.雙向圖(樹、無向圖)

```cpp
vector<vector<int>> adj;
int n, m;
cin >> n >> m;
adj.assign(n, {});

for (int i = 0; i < m; i++) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);
    adj[v].push_back(u);   // 關鍵：雙向連結
}
```

## 實戰應用

### 樹的基本操作

- 樹的遍歷（DFS/BFS）
- 樹的重建（前序+中序等）
- 樹的序列化與反序列化

### 樹的性質查詢

- 樹的高度/深度
- 樹的直徑
- 樹的重心
- 子樹大小

### 樹上路徑問題

- 兩點間距離
- 路徑上的最值
- 路徑權值和
- K級祖先查詢

### 樹的動態規劃

- 樹型DP
- 換根DP
- 樹上背包
- 樹上計數

### 樹的分治算法

- 重心分解
- 點分治
- 邊分治
- 長鏈剖分

---
在 LeetCode 入門題中，樹常以 TreeNode 類別搭配遞迴（DFS）操作，例如 `root.left`、`root.right`。
這種寫法的目的是降低初學者的理解門檻，而非貼近實際演算法設計或競賽需求。
在演算法競賽中，「樹」並不被視為一種物件結構，而是被納入圖論的範疇，作為一種特殊限制條件下的圖來處理，樹可以是一種無向無環連通圖。
